(*Dolev-Yao model Open Channel*)
free c:channel.
type list.
type tuple.
type none.
type nonce.
type skey.
type pkey.
type result.
type key.
free x_i: bitstring [private].
weaksecret x_i.

(* Randomness generated by Prover *)
free r_i: bitstring [private].
free v_i: bitstring [private].




(*noninterf r_i;
noninterf v_i;*)
(* Elliptic Curve *)
type G.
type L.


(*free nB: N [data].*)
(* Auxiliary Functions *)
fun templatehash(bitstring):bitstring.
fun mod(bitstring,L):bitstring.
fun mul(bitstring,bitstring):bitstring.
fun point_mul(G,G):G.
fun hash(G,G,G):bitstring.
fun map(bitstring):bitstring.(*secure function of 2H(x)+1*)
fun append(G,G,G):bitstring.
fun exp(G,bitstring):G.
fun sub(bitstring,bitstring):bitstring.
fun tpm_pcr_extend(bitstring,G):none.
fun ima_pp(bitstring,G,bitstring,bitstring):none.
fun ima_pp_event():G.
fun ima_pp_s():bitstring.
fun ima_pp_c():bitstring.
fun requestTPMQuote():bitstring.
fun hash_chain(G):bitstring.
fun retrieve_all():bitstring.
fun collect_results(G,bool):list.
fun retrieve_results(list):bitstring.
fun retrieve_event(list):G.
(* Public key Cryptography *)
fun pk(skey): pkey.

(* Signatures *)
fun ok () : result .
fun sign ( bitstring , skey ) : bitstring .
reduc forall m : bitstring , sk : skey ; getmess ( sign (m , sk ) ) = m .
reduc forall m : bitstring , sk : skey ; checksign ( sign (m , sk ) , pk(sk) ) = ok () .   


(*Events*)
event secureboot().
event requestAttestation(nonce).
event acceptAttestationRequest(nonce).(*attester*)
event sendAttestationResult(bitstring,list).(*attester*)
event requestpartialVerification(nonce,G,bitstring,bitstring,bitstring).(*attester*)
event verifiedAttestationResult(bitstring,G,bool).(*partialverifer*)
(*event failedAttestationResult(pkey,bitstring,bool).*)
event trustable().(*Verifier*)

(* A formal query, specifying the attacker can't ever be leaked the
actual binary and the randomness during the protocol. *)
query attacker(x_i).
query attacker(r_i).
query attacker(v_i).


query pk:pkey, n:nonce, event_hash:G, c_i:bitstring,c_i':bitstring, tpmQuote_signed:bitstring, result:bool, partialAttestationresults:list;
event(trustable())==>(event(sendAttestationResult(tpmQuote_signed,partialAttestationresults))==>event(verifiedAttestationResult(tpmQuote_signed,event_hash,result))).


noninterf x_i among (r_i,v_i,   ima_pp_c(), ima_pp_s()).

let verifier(pk:pkey) =
    new n:nonce;
    (*event requestAttestation(n);*)
    out(c,n);

    in (c,(tpmQuote_signed:bitstring, partialAttestationresults:list));
    let result' = retrieve_results(partialAttestationresults) in
    let event_hash = retrieve_event(partialAttestationresults) in
    let hash_chained = hash_chain(event_hash) in
    new valid:bitstring;
    let (hash_chained':bitstring, n':nonce) = getmess(tpmQuote_signed)in
    if checksign(tpmQuote_signed,pk) = ok() then
        if n' =n && hash_chained' = hash_chained && result' = valid then (
            event trustable()).


let attester(index:bitstring, pk:pkey, sk:skey, g:G,odr:L) =
    let event_hash = exp(g,mod(mul(r_i,mod(templatehash(x_i),odr)),odr)) in
    let g_i = exp(g, mod(templatehash(x_i),odr)) in
    let t_i = exp(g_i,v_i) in
    let c_i = hash(g_i,t_i,event_hash) in
    let s_i = mod(sub(v_i,mod(mul(r_i,mod(c_i,odr)),odr)),odr) in
    (*event secureboot();*)
    let pcr = tpm_pcr_extend(index,event_hash)in
    let ima = ima_pp(index,event_hash,c_i,s_i)in
    
    
    in(c,n:nonce);
    (*event acceptAttestationRequest(n);*)
    let tpmQuote = requestTPMQuote() in
    let tpmQuote_signed = sign(tpmQuote,sk) in
    let event_hash_ima = ima_pp_event() in
    let s_i_ima = ima_pp_s() in
    let c_i_ima= ima_pp_c() in
    (*event requestpartialVerification(n,event_hash_ima,c_i_ima,s_i_ima,tpmQuote_signed);*)
    out (c,(event_hash_ima,c_i_ima,s_i_ima,n,tpmQuote_signed));
    
    in (c,(tpmQuote_signed':bitstring,event_hash':G,attresult:bool));
    let partialAttestationresults = collect_results(event_hash',attresult) in
    event sendAttestationResult(tpmQuote_signed', partialAttestationresults);
    out(c,(tpmQuote_signed',partialAttestationresults)).
   
  

let partialVerifier(pk:pkey, g:G, odr:L)=
    in(c, (event_hash_ima:G,c_i_ima:bitstring,s_i_ima:bitstring,n:nonce, tpmQuote_signed:bitstring));
    let g_i = exp(g, mod(templatehash(x_i),odr)) in
    let g_i_s = exp(g_i,s_i_ima) in
    let event_hash_c = exp(event_hash_ima,mod(c_i_ima,odr)) in
    let t_i' = point_mul(g_i_s,event_hash_c) in
    let c_i' = hash(g_i,t_i',event_hash_ima) in 
    let hash_chained = hash_chain(event_hash_ima) in
    let (hash_chained':bitstring, n':nonce) = getmess(tpmQuote_signed)in
    if checksign(tpmQuote_signed,pk) = ok() then
        if c_i' = c_i_ima && n' = n && hash_chained' = hash_chained then (
            event verifiedAttestationResult(tpmQuote_signed,event_hash_ima,true);
            out(c,(tpmQuote_signed,event_hash_ima,true))).



process
    new sk:skey;
    let pkey = pk(sk) in
    new index:bitstring;
    new g: G;
    new odr:L;
    ((!verifier(pkey)) |  (!attester(index,pkey,sk,g,odr)) | (!partialVerifier(pkey,g,odr))  )
