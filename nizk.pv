(*Dolev-Yao model Open Channel*)
(*Channel between drone A and drone B*)
free c:channel.

type nonce.
free x_i: bitstring [private].
weaksecret x_i.


(* Elliptic Curve *)
type G.
type L.



(* Randomness Generated by Prover *)
free r_i: bitstring [private].
free v_i: bitstring [private].


(* A formal query, specifying the attacker can't ever be leaked the
actual binary and  the randomness during the protocol. *)
query attacker(x_i).
query attacker(r_i).
query attacker(v_i).

(*Auxiliary Functions*)
fun templatehash(bitstring):bitstring.
fun mod(bitstring,L):bitstring.
fun mul(bitstring,bitstring):bitstring.
fun point_mul(G,G):G.
fun hash(G,G,G):bitstring.
fun map(bitstring):bitstring.(*secure function of 2H(x)+1*)
fun append(G,G,G):bitstring.
fun exp(G,bitstring):G.
fun sub(bitstring,bitstring):bitstring.
(*fun check(bitstring,bitstring):bool.*)

(*Events*)
event end_NIZK_SIGN(G,bitstring,bitstring).
event end_NIZK_VERIFY(bitstring).


(* The process for Prover*)
let prover(g:G,odr:L) =
    (* Preparation *)
    (*new rA:bitstring;*)   
    (*let lA = map(lA) in*)

    let event_hash = exp(g,mod(mul(r_i,mod(templatehash(x_i),odr)),odr)) in
    let g_i = exp(g, mod(templatehash(x_i),odr)) in
    let t_i = exp(g_i,v_i) in
    let c_i = hash(g_i,t_i,event_hash) in
    let s_i = mod(sub(v_i,mod(mul(r_i,mod(c_i,odr)),odr)),odr) in

    out (c,(event_hash,c_i,s_i));
    event end_NIZK_SIGN(event_hash,c_i,s_i).

(* The process for Partial Verifier*)
let verifier(g:G,odr:L) =
    in(c, (event_hash:G,c_i:bitstring,s_i:bitstring));
    let g_i = exp(g, mod(templatehash(x_i),odr)) in
    let g_i_s = exp(g_i,s_i) in
    let event_hash_c = exp(event_hash,mod(c_i,odr)) in
    let t_i_prime = point_mul(g_i_s,event_hash_c) in
    let c_prime = hash(g_i,t_i_prime,event_hash) in 
    if c_prime = c_i then (
        event end_NIZK_VERIFY(c_prime)).

process
    new g: G;
    new odr:L;
    ((!prover(g,odr)) | (!verifier(g,odr)))